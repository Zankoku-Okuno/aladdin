sign extension is all 0s if positive, all 1s if negative

digit:
+--------------------------+
| sign-extend | signed int |
+--------------------------+

after digit-wise multiplication:
+--------------------+
| carry | signed int |
+--------------------+




       9  9
       9  9
      -- --
      81 81
   81 81
   -- -- --
    9  0  1
 9  0  1


9 0 1




        6  12  18
    5  10  15  
4   8  12

        7   3  8
    6   1   5  
4   9   2
-----------------
5   6   0   8  8


n-digit multiplicand A
m-digit multiplier B
(n+m)xm double-digit table of parital products M

for i in [0, n):
    for j in [0, m):
        Mi(i+j) = Ai*Bj

now, perform carries across every row
sum each column into a double-digit list
perform carries across this list into an m+n (or n+m-1) digit number







     0x F  F
+-----------+
|      d2 d2|E
|   e1 e1   |F
|-----------|0x
|    d  f  2|
| e  f  1   |
-------------
  e 1c 10  2 -> fd02


therefore, this algorithm is suitable only for magnitude-sign bit representations


probaly I'll use base-2 long division: whether to increment quotient takes only one step


def divrem(D, N)
    Q <- 0
    R <- 0
    for i from 



N = 100000
D = 001010

N 100000
D 001010
Q 
R 1

if D == 0 then throw DivisionByZeroException end
if N < D return 0, N
Q = []
R = []
while N
    R.push N.pop
  if R >= D
    R -= D  
    Q.push 1
  else
    Q.push 0
return Q, R



the thing with using a larger word size is that it falls back to this algorithm anyway to determine the string of 0s/1s to push onto Q. The only benefit is when the N and R are very different, we can find an upper bound quickly



Division:
in dividend, divisor
  if both are small: return native divrem
  if dividend is small: return 0, dividend
  if divisor small: cast divisor to bigint
  return bigint division

Division for two bigints:
in: numerator, denominator
  quotient <- 0
  remainder <- denominator
  loop 
    Find max left bit shifts such that shifted denominator < remainder.
    while positive left shifts,
      Increment quotient by 2**shifts.
      Decrement remainder by shifted denominator.
  return quotient, remainder.


